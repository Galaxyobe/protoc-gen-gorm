# protoc-gen-gorm

Generate gorm functions for protobuffer message.

## using the following extensions:

* message options

    - enabled

        enable generate

        default: false

* field options

    - primary_key

        when true mark the primary key field

        default: false

    - create_at

        when true mark the create at field

        default: false

    - update_at

        when true mark the update at field

        default: false

    - delete_at

        when true mark the delete at field

        default: false


## Installing and using

> go get -u github.com/galaxyobe/protoc-gen-gorm

> protoc $GOPATH/src -I . --go_out=. --gorm_out=. *.proto


gorm_out flag:

- inject-path
    same as generate output path

## example

See [test.proto](https://github.com/Galaxyobe/protoc-gen-gorm/blob/master/example/base.proto)
```protobuffer
syntax = "proto3";

package example;

import "github.com/gogo/protobuf/gogoproto/gogo.proto";
import "github.com/galaxyobe/protoc-gen-gorm/proto/gorm.proto";


message Base {
    option (gorm.enabled) = true;
    // uuid
    uint64 uuid = 1 [(gogoproto.moretags) = 'gorm:"primary_key"', (gorm.primary_key) = true];
    // name
    string name = 2 [(gogoproto.moretags) = 'gorm:"index:name"'];
    // create at
    int64 createAt = 3 [(gorm.create_at) = true];
    // update at
    int64 updateAt = 4 [(gorm.update_at) = true];
    // delete at
    int64 deleteAt = 5 [(gogoproto.moretags) = 'gorm:"index:date"', (gorm.delete_at) = true];
}

```
See [test.redis.go](https://github.com/Galaxyobe/protoc-gen-gorm/blob/master/example/base.gorm.go)
```golang
// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: base.proto

package example

import context "context"
import github_com_jinzhu_gorm "github.com/jinzhu/gorm"
import time "time"
import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/galaxyobe/protoc-gen-gorm/proto"
import _ "github.com/gogo/protobuf/gogoproto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// new Base GORM controller with gorm.DB
func (m *Base) GORMController(db *github_com_jinzhu_gorm.DB) *BaseGORMController {
	return &BaseGORMController{
		DB: db,
		m:  m,
	}
}

// new Base GORM controller with gorm.DB
func NewBaseGORMController(db *github_com_jinzhu_gorm.DB) *BaseGORMController {
	return &BaseGORMController{DB: db, m: new(Base)}
}

type BaseGORMController struct {
	DB *github_com_jinzhu_gorm.DB
	m  *Base
}

func (g *BaseGORMController) M(m *Base) {
	g.m = m
}

func (g *BaseGORMController) M() *Base {
	return g.m
}

func (g *BaseGORMController) AutoMigrate() {
	g.DB.AutoMigrate(g.m)
}

func (g *BaseGORMController) Begin() error {
	if db := g.DB.Begin(); db.Error != nil {
		return db.Error
	} else {
		g.DB = db
	}

	return nil
}

func (g *BaseGORMController) Rollback() *github_com_jinzhu_gorm.DB {
	return g.DB.Rollback()
}

func (g *BaseGORMController) Commit() *github_com_jinzhu_gorm.DB {
	return g.DB.Commit()
}

func (g *BaseGORMController) Create() *github_com_jinzhu_gorm.DB {
	now := time.Now().Unix()
	g.m.CreateAt = now
	g.m.UpdateAt = now

	return g.DB.Create(g.m)
}

func (g *BaseGORMController) Delete() *github_com_jinzhu_gorm.DB {
	if g.m.Uuid == 0 {
		g.DB.Error = errors.New("the value of Uuid is not expected to be 0")
		return g.DB
	}

	return g.DB.Delete(g.m)
}

func (g *BaseGORMController) SoftDelete() *github_com_jinzhu_gorm.DB {
	g.m.DeleteAt = time.Now().Unix()

	return g.DB.Model(g.m).Select("DeleteAt").Updates(g.m)
}

func (g *BaseGORMController) Update() *github_com_jinzhu_gorm.DB {
	g.m.UpdateAt = time.Now().Unix()

	return g.DB.Model(g.m).Omit("Uuid", "CreateAt", "DeleteAt").Updates(g.m)
}

func (g *BaseGORMController) First() (*Base, error) {
	db := g.DB.First(g.m)

	return g.m, db.Error
}

// when where is empty string will be ignored
// when order is empty is null: nil,-1,"" will be ignored
// when offset and limit is null: nil,-1,"" will be ignored
func (g *BaseGORMController) Find(where, limit, offset, order interface{}) ([]*Base, error) {
	var array []*Base

	db := g.DB.Where(where).Order(order).Limit(limit).Offset(offset).Find(&array)

	return array, db.Error
}

// when where is empty string will be ignored
// when order is empty is null: nil,-1,"" will be ignored
// when offset and limit is null: nil,-1,"" will be ignored
func (g *BaseGORMController) Count(where, limit, offset, order interface{}) (int64, error) {
	var count int64 = 0

	db := g.DB.Model(g.m).Where(where).Order(order).Limit(limit).Offset(offset).Count(&count)

	return count, db.Error
}

```

